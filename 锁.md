## Synchronized和Lock的区别

|类别|Synchronized|Lock|
|:----:|:------------------:|:----:|
|存在层次|JVM层面上|是一个类|
|锁的释放|1、以获取所得线程执行完同步代码，释放锁。2、线程执行一场，JVM会让线程释放锁|在finally中必须释放锁，否则易造成死锁|
|锁的获取|假设A线程获得锁，B线程等待，如果A线程阻塞，B线程会一直等待|分情况而定，可以通过不同的方式获取锁，线程可以不用一直等待|
|锁状态|无法判断|可以判断|
|锁类型|可冲入，不可中断，非公平|可充入，可判断，可公平|
|性能|少量同步|大量同步|


## 悲观锁和乐观锁
* 乐观锁在读取资源时默认资源没有被占用，只是在更新数据时去判断有没有别的线程对数据进行了更新，如果数据没有被更新，当前线程将自己修改的数据成功写入，如果数据已被别的线程更新，则根据不同的实现方式执行不同的操作（报错或自动重试）。这个过程一般采用CAS算法。
* 悲观锁在尝试使用数据时默认数据已被别的线程使用，所以先尝试加锁。synchronized和lock的实现类都是悲观锁。
  
## 使用场景
* 悲观锁适合写操作多的场景，能保证数据的的正确性。
* 乐观锁适合读多写少的场景，能尽可能的提高性能。  
* 乐观锁的实现  
    CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。  
    CAS算法涉及到三个操作数：
    需要读写的内存值 V。
    进行比较的值 A。
    要写入的新值 B。
    当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
## 自旋锁VS自适应性自旋锁
* 自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，知道获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是没有执行有效的任务，这种锁会造成busy-waiting（以进程反复检查一个条件是否为真为根本的技术，忙碌等待也可以用来产生一个任意的时间延迟）  
缺点：某个线程持有锁的时间过长，会导致其他等待获取锁的线程进入循环状态，消耗CPU，使用不当会导致cpu异常升高。
自旋锁是不公平的，无法保证等待时间最长的线程优先获取锁。产生线程饥饿问题（某个线程长时间占据cpu）。
## 无锁 偏向锁 轻量级锁  重量级锁
无锁：新建一个对象的默认状态  
偏向锁：只需比较 Thread ID，适用于单个线程重入  
轻量级锁：CAS自旋，速度快，但存在CPU空转问题  
重量级锁：需调用系统级互斥锁(mutex/monitor)，效率低  
GC标记：由markSweep使用，标记一个对象为无效状态
* Synchronized  
  修饰静态方法：锁住当前 class，作用于该 class 的所有实例
修饰非静态方法：只会锁住当前 class 的实例
修饰代码块：该方法接受一个对象作为参数，锁住的即该对象

锁升级过程  
1.6之前都是重量级锁

线程A进入Synchronized 开始抢锁，jvm会判断当前是否是偏向锁的状态，如果是会根据markword中存储的线程id来判断当前线程是否是持有偏向锁的线程，如果是则忽略check，线程A直接执行临界区内的代码。  
如果markword中的线程不是线程A，则通过自选尝试获取锁，如果获取到了，就将markword中的线程id改为自己的。如果竞争失败，则升级为轻量级锁。  
后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态依然是亲良机锁，如果竞争失败，锁会膨胀为重量级锁，后续竞争的线程都会被阻塞。
![锁升级](https://s4.51cto.com/images/blog/202203/07203815_6225fcb78be3f6427.jpg?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)
## 公平锁VS非公平锁
* 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，对类中的第一个线程才能获取锁，公平锁的优点是等待锁的线程不会饿死，缺点是吞吐率相对非公平锁来说姚笛，等待队列中除第一个线程外所有的线程都会阻塞，cpu唤醒阻塞线程的开销比非公平锁要大。
* 非公平锁是多个线程加锁时直接尝试获取锁，获取不到时才回到等待队列的队尾等待，但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请的线程先获取锁的场景，非公平锁的优点是可以减少唤醒线程的开销，整体的吞吐率较高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程，缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。





