# 序列化
![](https://img2020.cnblogs.com/other/1218593/202005/1218593-20200519085018322-1483445434.webp)
## 概念
    在jvm之外保存Java对象的状态，或者在网络中传输对象，以便在必要的时候还原该对象
## 序列化的方式
    Java 自带序列化，必须实现seriaizeable接口
    JSON,PROTOBUF,Hession等方式
## 问题
1. 什么是 serialVersionUID ？如果你不定义这个, 会发生什么？
    已序列化的对象将无法被还原，因为serialVersionId是一个对象的唯一标识，新生成的类与原来对象不被认为是同一对象
2. 序列化时,你希望某些成员不要序列化？你如何实现它？
    使用@transient注解
3. 如果类是可序列化的, 但其超类不是, 则反序列化后从超级类继承的实例变量的状态如何？
    Java 序列化过程仅在对象层级都是_可序列化_的类中继续， 即：实现了可序列化接口， 如果从超级类没有实现可序列化接口，则超级类继承的实例变量的值将通过调用构造函数初始化。
且一旦构造函数链启动, 就不可能停止， 因此， 即使层次结构中更高的类成员变量实现了可序列化接口， 也将通过执行构造函数创建，而不再是反序列化得到。
4. 是否可以自定义序列化和反序列化的过程？
    可以，在要序列化和反序列化的类中自定义writeObject(saveThisObject)和ObjectInputStream.readObject()
5. 序列化和反序列化中会用到哪些方法？
    Java 序列化由java.io.ObjectOutputStream类完成。该类是一个筛选器流, 它封装在较低级别的字节流中, 以处理序列化机制。要通过序列化机制存储任何对象, 我们调用 ObjectOutputStream.writeObject(savethisobject), 并反序列化该对象, 我们称之为 ObjectInputStream.readObject()方法。
调用以 writeObject() 方法在 java 中触发序列化过程。关于 readObject() 方法, 需要注意的一点很重要一点是, 它用于从持久性读取字节, 并从这些字节创建对象, 并返回一个对象, 该对象需要类型强制转换为正确的类型
